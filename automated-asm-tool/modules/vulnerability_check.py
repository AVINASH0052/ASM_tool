import logging
import time
import requests
from bs4 import BeautifulSoup

# Vulnerability scanner for web paths and data leaks
# Checks common exposures and misconfigurations
class VulnerabilityChecker:
    def __init__(self, domain):
        self.domain = domain
        self.user_agent = "ASM-Tool/2.0 (+https://github.com/your-repo)"
        self.breach_sources = [
            "https://leakpeek.com/search?q={domain}",
            "https://www.cyberprotect.it/check/domain/{domain}",
            "https://crt.sh/?q=%.{domain}&output=json"
        ]

    def check_breaches(self):
        """Search for domain in public breach databases"""
        breaches = []
        session = requests.Session()
        session.headers.update({'User-Agent': self.user_agent})
        
        try:
            # Check Certificate Transparency
            crt_data = session.get(
                f"https://crt.sh/?q=%.{self.domain}&output=json",
                timeout=15
            ).json()
            if any(entry.get('name_value') for entry in crt_data):
                breaches.append({
                    "source": "crt.sh",
                    "type": "Certificate Transparency",
                    "details": f"Found {len(crt_data)} certificates"
                })
        except Exception as e:
            logging.debug(f"CT check failed: {str(e)}")

        # Check other public sources
        sources = [
            ("leakpeek.com", "https://leakpeek.com/search?q=", 'div.result-item'),
            ("cyberprotect.it", "https://www.cyberprotect.it/check/domain/", 'div.alert-warning')
        ]
        
        for source_name, url_template, selector in sources:
            try:
                resp = session.get(url_template + self.domain, timeout=10)
                if resp.status_code == 200:
                    soup = BeautifulSoup(resp.text, 'html.parser')
                    if soup.select(selector):
                        breaches.append({
                            "source": source_name,
                            "type": "Potential Exposure",
                            "details": "Found in public database"
                        })
                time.sleep(2)  # Respect crawl delay
            except Exception as e:
                logging.debug(f"{source_name} check failed: {str(e)}")
                
        return breaches

    def find_sensitive_paths(self):
        """Check for exposed config/files"""
        paths = []
        critical_paths = [
            '/.env', '/.git/HEAD', '/wp-config.php',
            '/aws.yml', '/docker-compose.yaml', '/admin',
            '/backup', '/config.json', '/wp-login.php'
        ]
        
        session = requests.Session()
        session.headers.update({
            'User-Agent': self.user_agent,
            'Accept-Encoding': 'gzip, deflate'
        })
        
        for path in critical_paths:
            for scheme in ['https', 'http']:
                url = f"{scheme}://{self.domain}/{path.lstrip('/')}"
                try:
                    resp = session.get(
                        url,
                        timeout=8,
                        allow_redirects=False,
                        verify=False
                    )
                    if resp.status_code in {200, 403, 401}:
                        paths.append({
                            "url": url,
                            "status": resp.status_code,
                            "content_type": resp.headers.get('Content-Type', ''),
                            "length": len(resp.content)
                        })
                        break  # Stop checking other schemes if found
                except Exception as e:
                    continue
                    
        return paths

    def scan(self):
        """Run full vulnerability assessment"""
        results = {'osint_findings': [], 'sensitive_paths': []}
        
        try:
            results['osint_findings'] = self.check_breaches()
        except Exception as e:
            logging.error(f"OSINT failed: {str(e)}")
        
        try:
            results['sensitive_paths'] = self.find_sensitive_paths()
        except Exception as e:
            logging.error(f"Path scan failed: {str(e)}")
        
        return results